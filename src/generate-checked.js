/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Spec from "shift-spec";
import {keyword} from "esutils";
const {isRestrictedWord, isReservedWordES6} = keyword;

function sanitize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return '_' + fieldName;
  }
  return fieldName;
}

function parameterize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return fieldName + ': _' + fieldName;
  }
  return fieldName;
}

function printType(type, flattenUnion = false) {
  if (type === ExpressionType) {
    return 'Expression';
  } else if (type === StatementType) {
    return 'Statement';
  }
  switch (type.typeName) {
    case 'Boolean':
      return 'boolean';
    case 'Number':
      return 'number';
    case 'String':
      return 'string';
    case 'Maybe':
      return `null or ${printType(type.argument)}`;
    case 'List':
      return `[${printType(type.argument)}]`;
    case 'Union':
      let types = `${type.arguments.map(t=>printType(t, true)).join(', ')}`;
      if (flattenUnion) {
        return types;
      }
      return `one of {${types}}`;
    case 'Enum':
      return `one of {${type.values.map(x=>`"${x}"`).join(', ')}}`;
    default:
      return type.typeName;
  }
}

const ExpressionType = Spec.ExpressionStatement.fields[1].type;
const StatementType = Spec.LabeledStatement.fields[2].type;
function typeCheck(name, type, {includeUndefCheck = true, isExpressionCheck = false, isStatementCheck = false} = {}) {
  if (!isExpressionCheck && type === ExpressionType) {
    return `isNotExpression(${name})`;
  }
  if (!isStatementCheck && type === StatementType) {
    return `isNotStatement(${name})`;
  }
  let check = includeUndefCheck ? `${name} === undefined || ` : '';
  switch (type.typeName) {
    case 'Boolean':
      check += `typeof ${name} !== 'boolean'`;
      break;
    case 'Number':
      check += `typeof ${name} !== 'number'`;
      break;
    case 'String':
      check += `typeof ${name} !== 'string'`;
      break;
    case 'Maybe':
      check += `${name} !== null && (${typeCheck(name, type.argument, {includeUndefCheck: false})})`;
      break;
    case 'List':
      check += `!Array.isArray(${name}) || ${name}.some(f => ${typeCheck('f', type.argument)})`;
      break;
    case 'Union':
      check += type.arguments.map(t => `(${typeCheck(name, t, {includeUndefCheck: false})})`).join(' && ');
      break;
    case 'Enum':
      check += `${JSON.stringify(type.values)}.indexOf(${name}) === -1`;
      break;
    default:
      check += `${name}.type !== '${type.typeName}'`;
      break;
  }
  return check;
}

let content = `// Generated by src/${require('path').basename(__filename)}.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return ${typeCheck('node', ExpressionType, {isExpressionCheck: true})};
}

function isNotStatement(node) {
  return ${typeCheck('node', StatementType, {isStatementCheck: true})};
}
`;


for (let typename in Spec) {
  let type = Spec[typename];
  let fields = type.fields.filter(f => (f.name !== 'type' && f.name !== 'loc'));
  let param, paramCheck;
  if (fields.length > 0) {
    param = '{' + fields.map(f => parameterize(f.name)).join(', ') + '}';
    paramCheck = fields.map(f => {
      let fname = sanitize(f.name);
      return `
    if (${typeCheck(fname, f.type)}) {
      throw new TypeError('Field "${f.name}" of ${typename} constructor is of incorrect type (expected ${printType(f.type)})');
    }`
      }).join('');
  } else {
    param = '';
    paramCheck = '';
  }
  content += `
export class ${typename} {
  constructor(${param}) {${paramCheck}
    this.type = '${typename}';${fields.map(f => `\n    this.${f.name} = ${sanitize(f.name)};`).join('')}
  }
}
`
}

require("fs").writeFileSync("gen/checked.js", content, "utf-8");
