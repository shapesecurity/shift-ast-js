/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Spec = require('shift-spec').default;
const { keyword } = require('esutils');
const { isRestrictedWord, isReservedWordES6 } = keyword;

const ExpressionType = Spec.ExpressionStatement.fields[1].type;
const StatementType = Spec.LabeledStatement.fields[2].type;

function sanitize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return '_' + fieldName;
  }
  return fieldName;
}

function parameterize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return fieldName + ': _' + fieldName;
  }
  return fieldName;
}

function printType(type, flattenUnion = false) {
  if (type === ExpressionType) {
    return 'Expression';
  } else if (type === StatementType) {
    return 'Statement';
  }
  switch (type.typeName) {
    case 'Boolean':
      return 'boolean';
    case 'Number':
      return 'number';
    case 'String':
      return 'string';
    case 'Maybe':
      return `null or ${printType(type.argument)}`;
    case 'List':
      return `[${printType(type.argument)}]`;
    case 'Union': {
      let types = `${type.arguments.map(t => printType(t, true)).join(', ')}`;
      if (flattenUnion) {
        return types;
      }
      return `one of {${types}}`;
    }
    case 'Enum':
      return `one of {${type.values.map(x => `"${x}"`).join(', ')}}`;
    default:
      return type.typeName;
  }
}

function typeCheck(name, type, { includeUndefCheck = true, isExpressionCheck = false, isStatementCheck = false } = {}) {
  if (!isExpressionCheck && type === ExpressionType) {
    return `isNotExpression(${name})`;
  }
  if (!isStatementCheck && type === StatementType) {
    return `isNotStatement(${name})`;
  }
  let check = includeUndefCheck && type.typeName !== 'Boolean' && type.typeName !== 'Number' && type.typeName !== 'String' ? `typeof ${name} === 'undefined' || ` : '';
  switch (type.typeName) {
    case 'Boolean':
      check += `typeof ${name} !== 'boolean'`;
      break;
    case 'Number':
      check += `typeof ${name} !== 'number'`;
      break;
    case 'String':
      check += `typeof ${name} !== 'string'`;
      break;
    case 'Maybe':
      check += `${name} !== null && (${typeCheck(name, type.argument, { includeUndefCheck: false })})`;
      break;
    case 'List':
      check += `!Array.isArray(${name}) || ${name}.some(f => ${typeCheck('f', type.argument)})`;
      break;
    case 'Union':
      check += type.arguments.map(t => `(${typeCheck(name, t, { includeUndefCheck: false })})`).join(' && ');
      break;
    case 'Enum':
      check += `[${type.values.map(o => `'${o}'`).join(', ')}].indexOf(${name}) === -1`;
      break;
    default:
      check += `${name}.type !== '${type.typeName}'`;
      break;
  }
  return check;
}

let content = `// Generated by src/${require('path').basename(__filename)}.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return ${typeCheck('node', ExpressionType, { isExpressionCheck: true })};
}

function isNotStatement(node) {
  return ${typeCheck('node', StatementType, { isStatementCheck: true })};
}

function printActualType(arg) {
  if (typeof arg !== 'object') {
    return typeof arg;
  }
  if (Array.isArray(arg)) {
    return \`[\${arg.map(printActualType).join(', ')}]\`;
  }
  if (arg === null) {
    return null;
  }
  if (!arg.type) {
    return JSON.stringify(arg);
  }
  return arg.type;
}
`;


for (let typename of Object.keys(Spec)) {
  let type = Spec[typename];
  let fields = type.fields.filter(f => f.name !== 'type' && f.name !== 'loc');
  let param, paramCheck;
  if (fields.length > 0) {
    param = '{ ' + fields.map(f => parameterize(f.name)).join(', ') + ' }';
    paramCheck = fields.map(f => {
      let fname = sanitize(f.name);
      return `
    if (${typeCheck(fname, f.type)}) {
      throw new TypeError('Field "${f.name}" of ${typename} constructor is of incorrect type (expected ${printType(f.type)}, got ' + printActualType(${fname}) + ')');
    }`;
    }).join('');
  } else {
    param = '';
    paramCheck = '';
  }
  content += `
export class ${typename} {
  constructor(${param}) {${paramCheck}
    this.type = '${typename}';${fields.map(f => `\n    this.${f.name} = ${sanitize(f.name)};`).join('')}
  }
}
`;
}

require('fs').writeFileSync('gen/checked.js', content, 'utf-8');
