/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Spec = require('shift-spec');
const { keyword } = require('esutils');
const { isRestrictedWord, isReservedWordES6 } = keyword;

const ExpressionType = Spec.ExpressionStatement.fields[1].type;
const StatementType = Spec.LabeledStatement.fields[2].type;

function sanitize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return '_' + fieldName;
  }
  return fieldName;
}

function parameterize(fieldName) {
  if (isRestrictedWord(fieldName) || isReservedWordES6(fieldName)) {
    return fieldName + ': _' + fieldName;
  }
  return fieldName;
}

function printType(type, flattenUnion = false) {
  if (type === ExpressionType) {
    return 'Expression';
  } else if (type === StatementType) {
    return 'Statement';
  }
  switch (type.typeName) {
    case 'Boolean':
      return 'boolean';
    case 'Number':
      return 'number';
    case 'String':
      return 'string';
    case 'Maybe':
      return `null or ${printType(type.argument)}`;
    case 'List':
      return `[${printType(type.argument)}]`;
    case 'Union': {
      let types = `${type.arguments.map(t => printType(t, true)).join(', ')}`;
      if (flattenUnion) {
        return types;
      }
      return `one of {${types}}`;
    }
    case 'Enum':
      return `one of {${type.values.map(x => `"${x}"`).join(', ')}}`;
    default:
      return type.typeName;
  }
}

function typeCheck(name, type, { includeUndefCheck = true, isExpressionCheck = false, isStatementCheck = false } = {}) {
  if (!isExpressionCheck && type === ExpressionType) {
    return `isNotExpression(${name})`;
  }
  if (!isStatementCheck && type === StatementType) {
    return `isNotStatement(${name})`;
  }
  let check = includeUndefCheck && type.typeName !== 'Boolean' && type.typeName !== 'Number' && type.typeName !== 'String' && type.typeName !== 'List'
    ? `typeof ${name} === 'undefined' || `
    : '';
  switch (type.typeName) {
    case 'Boolean':
      check += `typeof ${name} !== 'boolean'`;
      break;
    case 'Number':
      check += `typeof ${name} !== 'number'`;
      break;
    case 'String':
      check += `typeof ${name} !== 'string'`;
      break;
    case 'Maybe':
      check += `${name} !== null && (${typeCheck(name, type.argument, { includeUndefCheck: false })})`;
      break;
    case 'List':
      check += `!Array.isArray(${name}) || ${name}.some(f => ${typeCheck('f', type.argument)})`;
      break;
    case 'Union':
      check += type.arguments.map(t => `(${typeCheck(name, t, { includeUndefCheck: false })})`).join(' && ');
      break;
    case 'Enum':
      check += `[${type.values.map(o => `'${o}'`).join(', ')}].indexOf(${name}) === -1`;
      break;
    default:
      check += `${name}.type !== '${type.typeName}'`;
      break;
  }
  return check;
}

let content = `// Generated by scripts/${require('path').basename(__filename)}.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return ${typeCheck('node', ExpressionType, { isExpressionCheck: true })};
}

function isNotStatement(node) {
  return ${typeCheck('node', StatementType, { isStatementCheck: true })};
}

function printActualType(arg) {
  if (typeof arg !== 'object') {
    return typeof arg;
  }
  if (Array.isArray(arg)) {
    return \`[\${arg.map(printActualType).join(', ')}]\`;
  }
  if (arg === null) {
    return null;
  }
  if (!arg.type) {
    return JSON.stringify(arg);
  }
  return arg.type;
}

function arrayEquals(a, b) {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}
`;


for (let typename of Object.keys(Spec)) {
  let type = Spec[typename];
  let fields = type.fields.filter(f => f.name !== 'type' && f.name !== 'loc');
  if (fields.length === 0) {
    content += `
exports.${typename} = class {
  constructor(...extraArgs) {
    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {
      throw new TypeError('${typename} constructor takes no arguments');
    }
    this.type = '${typename}';
  }
};
`;
  } else {
    let expectedArgs = '{' + fields.map(f => f.name).join(', ') + '}';
    let expectedArgsSorted = '[' + fields.map(f => '\'' + f.name + '\'').sort().join(', ') + ']';
    let param = '{ ' + fields.map(f => parameterize(f.name)).join(', ') + ' }';
    let paramCheck = fields.map(f => {
      let fname = sanitize(f.name);
      return `if (${typeCheck(fname, f.type)}) {
      throw new TypeError('Field "${f.name}" of ${typename} constructor argument is of incorrect type (expected ${printType(f.type)}, got ' + printActualType(${fname}) + ')');
    }`;
    }).join('\n    ');
    content += `
exports.${typename} = class {
  constructor(arg, ...extraArgs) {
    const ${param} = arg;
    if (extraArgs.length !== 0) {
      throw new TypeError('${typename} constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');
    }
    if (!arrayEquals(Object.keys(arg).sort(), ${expectedArgsSorted})) {
      throw new TypeError('Argument to ${typename} constructor has wrong keys: expected ${expectedArgs.replace(/'/g, '\\\'')}, got {' + Object.keys(arg).join(', ') + '}');
    }
    ${paramCheck}
    this.type = '${typename}';
    ${fields.map(f => `this.${f.name} = ${sanitize(f.name)};`).join('\n    ')}
  }
};
`;

  }
}

require('fs').writeFileSync('gen/checked.js', content, 'utf-8');
