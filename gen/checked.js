// Generated by src/generate-checked.js.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return typeof node === 'undefined' || (node.type !== 'ArrayExpression') && (node.type !== 'ArrowExpression') && (node.type !== 'AssignmentExpression') && (node.type !== 'BinaryExpression') && (node.type !== 'CallExpression') && (node.type !== 'ClassExpression') && (node.type !== 'CompoundAssignmentExpression') && (node.type !== 'ConditionalExpression') && (node.type !== 'FunctionExpression') && (node.type !== 'IdentifierExpression') && (node.type !== 'LiteralBooleanExpression') && (node.type !== 'LiteralInfinityExpression') && (node.type !== 'LiteralNullExpression') && (node.type !== 'LiteralNumericExpression') && (node.type !== 'LiteralRegExpExpression') && (node.type !== 'LiteralStringExpression') && ((node.type !== 'ComputedMemberExpression') && (node.type !== 'StaticMemberExpression')) && (node.type !== 'NewExpression') && (node.type !== 'NewTargetExpression') && (node.type !== 'ObjectExpression') && (node.type !== 'TemplateExpression') && (node.type !== 'ThisExpression') && (node.type !== 'UnaryExpression') && (node.type !== 'UpdateExpression') && (node.type !== 'YieldExpression') && (node.type !== 'YieldGeneratorExpression');
}

function isNotStatement(node) {
  return typeof node === 'undefined' || (node.type !== 'BlockStatement') && (node.type !== 'BreakStatement') && (node.type !== 'ClassDeclaration') && (node.type !== 'ContinueStatement') && (node.type !== 'DebuggerStatement') && (node.type !== 'EmptyStatement') && (node.type !== 'ExpressionStatement') && (node.type !== 'FunctionDeclaration') && (node.type !== 'IfStatement') && ((node.type !== 'DoWhileStatement') && (node.type !== 'ForInStatement') && (node.type !== 'ForOfStatement') && (node.type !== 'ForStatement') && (node.type !== 'WhileStatement')) && (node.type !== 'LabeledStatement') && (node.type !== 'ReturnStatement') && (node.type !== 'SwitchStatement') && (node.type !== 'SwitchStatementWithDefault') && (node.type !== 'ThrowStatement') && (node.type !== 'TryCatchStatement') && (node.type !== 'TryFinallyStatement') && (node.type !== 'VariableDeclarationStatement') && (node.type !== 'WithStatement');
}

function printActualType(arg) {
  if (typeof arg !== 'object') {
    return typeof arg;
  }
  if (Array.isArray(arg)) {
    return `[${arg.map(printActualType).join(', ')}]`;
  }
  if (arg === null) {
    return null;
  }
  if (!arg.type) {
    return JSON.stringify(arg);
  }
  return arg.type;
}

export class ArrayAssignmentTarget {
  constructor({ elements, rest }) {
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((f.type !== 'AssignmentTargetWithDefault') && (((f.type !== 'ArrayAssignmentTarget') && (f.type !== 'ObjectAssignmentTarget')) && ((f.type !== 'AssignmentTargetIdentifier') && ((f.type !== 'ComputedMemberAssignmentTarget') && (f.type !== 'StaticMemberAssignmentTarget'))))))) {
      throw new TypeError('Field "elements" of ArrayAssignmentTarget constructor is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got ' + printActualType(elements) + ')');
    }
    if (typeof rest === 'undefined' || rest !== null && (((rest.type !== 'ArrayAssignmentTarget') && (rest.type !== 'ObjectAssignmentTarget')) && ((rest.type !== 'AssignmentTargetIdentifier') && ((rest.type !== 'ComputedMemberAssignmentTarget') && (rest.type !== 'StaticMemberAssignmentTarget'))))) {
      throw new TypeError('Field "rest" of ArrayAssignmentTarget constructor is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');
    }
    this.type = 'ArrayAssignmentTarget';
    this.elements = elements;
    this.rest = rest;
  }
}

export class ArrayBinding {
  constructor({ elements, rest }) {
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding')))))) {
      throw new TypeError('Field "elements" of ArrayBinding constructor is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(elements) + ')');
    }
    if (typeof rest === 'undefined' || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "rest" of ArrayBinding constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
    }
    this.type = 'ArrayBinding';
    this.elements = elements;
    this.rest = rest;
  }
}

export class ArrayExpression {
  constructor({ elements }) {
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((isNotExpression(f)) && (f.type !== 'SpreadElement')))) {
      throw new TypeError('Field "elements" of ArrayExpression constructor is of incorrect type (expected [null or one of {Expression, SpreadElement}], got ' + printActualType(elements) + ')');
    }
    this.type = 'ArrayExpression';
    this.elements = elements;
  }
}

export class ArrowExpression {
  constructor({ params, body }) {
    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of ArrowExpression constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
    }
    if (typeof body === 'undefined' || (isNotExpression(body)) && (body.type !== 'FunctionBody')) {
      throw new TypeError('Field "body" of ArrowExpression constructor is of incorrect type (expected one of {Expression, FunctionBody}, got ' + printActualType(body) + ')');
    }
    this.type = 'ArrowExpression';
    this.params = params;
    this.body = body;
  }
}

export class AssignmentExpression {
  constructor({ binding, expression }) {
    if (typeof binding === 'undefined' || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {
      throw new TypeError('Field "binding" of AssignmentExpression constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of AssignmentExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'AssignmentExpression';
    this.binding = binding;
    this.expression = expression;
  }
}

export class AssignmentTargetIdentifier {
  constructor({ name }) {
    if (typeof name !== 'string') {
      throw new TypeError('Field "name" of AssignmentTargetIdentifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
    }
    this.type = 'AssignmentTargetIdentifier';
    this.name = name;
  }
}

export class AssignmentTargetPropertyIdentifier {
  constructor({ binding, init }) {
    if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier') {
      throw new TypeError('Field "binding" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected AssignmentTargetIdentifier, got ' + printActualType(binding) + ')');
    }
    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
    }
    this.type = 'AssignmentTargetPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  }
}

export class AssignmentTargetPropertyProperty {
  constructor({ name, binding }) {
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (typeof binding === 'undefined' || (binding.type !== 'AssignmentTargetWithDefault') && (((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))))) {
      throw new TypeError('Field "binding" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
    }
    this.type = 'AssignmentTargetPropertyProperty';
    this.name = name;
    this.binding = binding;
  }
}

export class AssignmentTargetWithDefault {
  constructor({ binding, init }) {
    if (typeof binding === 'undefined' || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {
      throw new TypeError('Field "binding" of AssignmentTargetWithDefault constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
    }
    if (isNotExpression(init)) {
      throw new TypeError('Field "init" of AssignmentTargetWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
    }
    this.type = 'AssignmentTargetWithDefault';
    this.binding = binding;
    this.init = init;
  }
}

export class BinaryExpression {
  constructor({ left, operator, right }) {
    if (isNotExpression(left)) {
      throw new TypeError('Field "left" of BinaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(left) + ')');
    }
    if (typeof operator === 'undefined' || ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof', '<<', '>>', '>>>', '+', '-', '*', '/', '%', '**', ',', '||', '&&', '|', '^', '&'].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of BinaryExpression constructor is of incorrect type (expected one of {"==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"}, got ' + printActualType(operator) + ')');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of BinaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
    }
    this.type = 'BinaryExpression';
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
}

export class BindingIdentifier {
  constructor({ name }) {
    if (typeof name !== 'string') {
      throw new TypeError('Field "name" of BindingIdentifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
    }
    this.type = 'BindingIdentifier';
    this.name = name;
  }
}

export class BindingPropertyIdentifier {
  constructor({ binding, init }) {
    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "binding" of BindingPropertyIdentifier constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
    }
    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of BindingPropertyIdentifier constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
    }
    this.type = 'BindingPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  }
}

export class BindingPropertyProperty {
  constructor({ name, binding }) {
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of BindingPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (typeof binding === 'undefined' || (binding.type !== 'BindingWithDefault') && ((binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "binding" of BindingPropertyProperty constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
    }
    this.type = 'BindingPropertyProperty';
    this.name = name;
    this.binding = binding;
  }
}

export class BindingWithDefault {
  constructor({ binding, init }) {
    if (typeof binding === 'undefined' || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of BindingWithDefault constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
    }
    if (isNotExpression(init)) {
      throw new TypeError('Field "init" of BindingWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
    }
    this.type = 'BindingWithDefault';
    this.binding = binding;
    this.init = init;
  }
}

export class Block {
  constructor({ statements }) {
    if (typeof statements === 'undefined' || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of Block constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
    }
    this.type = 'Block';
    this.statements = statements;
  }
}

export class BlockStatement {
  constructor({ block }) {
    if (typeof block === 'undefined' || block.type !== 'Block') {
      throw new TypeError('Field "block" of BlockStatement constructor is of incorrect type (expected Block, got ' + printActualType(block) + ')');
    }
    this.type = 'BlockStatement';
    this.block = block;
  }
}

export class BreakStatement {
  constructor({ label }) {
    if (typeof label === 'undefined' || label !== null && (typeof label !== 'string')) {
      throw new TypeError('Field "label" of BreakStatement constructor is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
    }
    this.type = 'BreakStatement';
    this.label = label;
  }
}

export class CallExpression {
  constructor({ callee, arguments: _arguments }) {
    if (typeof callee === 'undefined' || (isNotExpression(callee)) && (callee.type !== 'Super')) {
      throw new TypeError('Field "callee" of CallExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(callee) + ')');
    }
    if (typeof _arguments === 'undefined' || !Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {
      throw new TypeError('Field "arguments" of CallExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
    }
    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = _arguments;
  }
}

export class CatchClause {
  constructor({ binding, body }) {
    if (typeof binding === 'undefined' || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of CatchClause constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'Block') {
      throw new TypeError('Field "body" of CatchClause constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
    }
    this.type = 'CatchClause';
    this.binding = binding;
    this.body = body;
  }
}

export class ClassDeclaration {
  constructor({ name, super: _super, elements }) {
    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {
      throw new TypeError('Field "name" of ClassDeclaration constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
    }
    if (typeof _super === 'undefined' || _super !== null && (isNotExpression(_super))) {
      throw new TypeError('Field "super" of ClassDeclaration constructor is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
    }
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {
      throw new TypeError('Field "elements" of ClassDeclaration constructor is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
    }
    this.type = 'ClassDeclaration';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  }
}

export class ClassElement {
  constructor({ isStatic, method }) {
    if (typeof isStatic !== 'boolean') {
      throw new TypeError('Field "isStatic" of ClassElement constructor is of incorrect type (expected boolean, got ' + printActualType(isStatic) + ')');
    }
    if (typeof method === 'undefined' || (method.type !== 'Getter') && (method.type !== 'Method') && (method.type !== 'Setter')) {
      throw new TypeError('Field "method" of ClassElement constructor is of incorrect type (expected one of {Getter, Method, Setter}, got ' + printActualType(method) + ')');
    }
    this.type = 'ClassElement';
    this.isStatic = isStatic;
    this.method = method;
  }
}

export class ClassExpression {
  constructor({ name, super: _super, elements }) {
    if (typeof name === 'undefined' || name !== null && (name.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "name" of ClassExpression constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
    }
    if (typeof _super === 'undefined' || _super !== null && (isNotExpression(_super))) {
      throw new TypeError('Field "super" of ClassExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
    }
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {
      throw new TypeError('Field "elements" of ClassExpression constructor is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
    }
    this.type = 'ClassExpression';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  }
}

export class CompoundAssignmentExpression {
  constructor({ binding, operator, expression }) {
    if (typeof binding === 'undefined' || (binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))) {
      throw new TypeError('Field "binding" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
    }
    if (typeof operator === 'undefined' || ['+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '|=', '^=', '&='].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {"+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="}, got ' + printActualType(operator) + ')');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of CompoundAssignmentExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'CompoundAssignmentExpression';
    this.binding = binding;
    this.operator = operator;
    this.expression = expression;
  }
}

export class ComputedMemberAssignmentTarget {
  constructor({ object, expression }) {
    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ComputedMemberAssignmentTarget';
    this.object = object;
    this.expression = expression;
  }
}

export class ComputedMemberExpression {
  constructor({ object, expression }) {
    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of ComputedMemberExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedMemberExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ComputedMemberExpression';
    this.object = object;
    this.expression = expression;
  }
}

export class ComputedPropertyName {
  constructor({ expression }) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ComputedPropertyName constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ComputedPropertyName';
    this.expression = expression;
  }
}

export class ConditionalExpression {
  constructor({ test, consequent, alternate }) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
    }
    if (isNotExpression(consequent)) {
      throw new TypeError('Field "consequent" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(consequent) + ')');
    }
    if (isNotExpression(alternate)) {
      throw new TypeError('Field "alternate" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(alternate) + ')');
    }
    this.type = 'ConditionalExpression';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
}

export class ContinueStatement {
  constructor({ label }) {
    if (typeof label === 'undefined' || label !== null && (typeof label !== 'string')) {
      throw new TypeError('Field "label" of ContinueStatement constructor is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
    }
    this.type = 'ContinueStatement';
    this.label = label;
  }
}

export class DataProperty {
  constructor({ name, expression }) {
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of DataProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of DataProperty constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'DataProperty';
    this.name = name;
    this.expression = expression;
  }
}

export class DebuggerStatement {
  constructor() {
    this.type = 'DebuggerStatement';
  }
}

export class Directive {
  constructor({ rawValue }) {
    if (typeof rawValue !== 'string') {
      throw new TypeError('Field "rawValue" of Directive constructor is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
    }
    this.type = 'Directive';
    this.rawValue = rawValue;
  }
}

export class DoWhileStatement {
  constructor({ body, test }) {
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of DoWhileStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of DoWhileStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
    }
    this.type = 'DoWhileStatement';
    this.body = body;
    this.test = test;
  }
}

export class EmptyStatement {
  constructor() {
    this.type = 'EmptyStatement';
  }
}

export class Export {
  constructor({ declaration }) {
    if (typeof declaration === 'undefined' || (declaration.type !== 'ClassDeclaration') && (declaration.type !== 'FunctionDeclaration') && (declaration.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "declaration" of Export constructor is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got ' + printActualType(declaration) + ')');
    }
    this.type = 'Export';
    this.declaration = declaration;
  }
}

export class ExportAllFrom {
  constructor({ moduleSpecifier }) {
    if (typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ExportAllFrom constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
    }
    this.type = 'ExportAllFrom';
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ExportDefault {
  constructor({ body }) {
    if (typeof body === 'undefined' || (body.type !== 'ClassDeclaration') && (isNotExpression(body)) && (body.type !== 'FunctionDeclaration')) {
      throw new TypeError('Field "body" of ExportDefault constructor is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got ' + printActualType(body) + ')');
    }
    this.type = 'ExportDefault';
    this.body = body;
  }
}

export class ExportFrom {
  constructor({ namedExports, moduleSpecifier }) {
    if (typeof namedExports === 'undefined' || !Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportFromSpecifier')) {
      throw new TypeError('Field "namedExports" of ExportFrom constructor is of incorrect type (expected [ExportFromSpecifier], got ' + printActualType(namedExports) + ')');
    }
    if (typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ExportFrom constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
    }
    this.type = 'ExportFrom';
    this.namedExports = namedExports;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ExportFromSpecifier {
  constructor({ name, exportedName }) {
    if (typeof name !== 'string') {
      throw new TypeError('Field "name" of ExportFromSpecifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
    }
    if (typeof exportedName === 'undefined' || exportedName !== null && (typeof exportedName !== 'string')) {
      throw new TypeError('Field "exportedName" of ExportFromSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
    }
    this.type = 'ExportFromSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  }
}

export class ExportLocalSpecifier {
  constructor({ name, exportedName }) {
    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {
      throw new TypeError('Field "name" of ExportLocalSpecifier constructor is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
    }
    if (typeof exportedName === 'undefined' || exportedName !== null && (typeof exportedName !== 'string')) {
      throw new TypeError('Field "exportedName" of ExportLocalSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
    }
    this.type = 'ExportLocalSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  }
}

export class ExportLocals {
  constructor({ namedExports }) {
    if (typeof namedExports === 'undefined' || !Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportLocalSpecifier')) {
      throw new TypeError('Field "namedExports" of ExportLocals constructor is of incorrect type (expected [ExportLocalSpecifier], got ' + printActualType(namedExports) + ')');
    }
    this.type = 'ExportLocals';
    this.namedExports = namedExports;
  }
}

export class ExpressionStatement {
  constructor({ expression }) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ExpressionStatement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ExpressionStatement';
    this.expression = expression;
  }
}

export class ForInStatement {
  constructor({ left, right, body }) {
    if (typeof left === 'undefined' || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "left" of ForInStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of ForInStatement constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForInStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'ForInStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  }
}

export class ForOfStatement {
  constructor({ left, right, body }) {
    if (typeof left === 'undefined' || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {
      throw new TypeError('Field "left" of ForOfStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
    }
    if (isNotExpression(right)) {
      throw new TypeError('Field "right" of ForOfStatement constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForOfStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'ForOfStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  }
}

export class ForStatement {
  constructor({ init, test, update, body }) {
    if (typeof init === 'undefined' || init !== null && ((isNotExpression(init)) && (init.type !== 'VariableDeclaration'))) {
      throw new TypeError('Field "init" of ForStatement constructor is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got ' + printActualType(init) + ')');
    }
    if (typeof test === 'undefined' || test !== null && (isNotExpression(test))) {
      throw new TypeError('Field "test" of ForStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(test) + ')');
    }
    if (typeof update === 'undefined' || update !== null && (isNotExpression(update))) {
      throw new TypeError('Field "update" of ForStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(update) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of ForStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'ForStatement';
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
  }
}

export class FormalParameters {
  constructor({ items, rest }) {
    if (typeof items === 'undefined' || !Array.isArray(items) || items.some(f => typeof f === 'undefined' || (f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding'))))) {
      throw new TypeError('Field "items" of FormalParameters constructor is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(items) + ')');
    }
    if (typeof rest === 'undefined' || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "rest" of FormalParameters constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
    }
    this.type = 'FormalParameters';
    this.items = items;
    this.rest = rest;
  }
}

export class FunctionBody {
  constructor({ directives, statements }) {
    if (typeof directives === 'undefined' || !Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of FunctionBody constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
    }
    if (typeof statements === 'undefined' || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of FunctionBody constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
    }
    this.type = 'FunctionBody';
    this.directives = directives;
    this.statements = statements;
  }
}

export class FunctionDeclaration {
  constructor({ isGenerator, name, params, body }) {
    if (typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of FunctionDeclaration constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
    }
    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {
      throw new TypeError('Field "name" of FunctionDeclaration constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
    }
    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of FunctionDeclaration constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of FunctionDeclaration constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
    }
    this.type = 'FunctionDeclaration';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class FunctionExpression {
  constructor({ isGenerator, name, params, body }) {
    if (typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of FunctionExpression constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
    }
    if (typeof name === 'undefined' || name !== null && (name.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "name" of FunctionExpression constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
    }
    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of FunctionExpression constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of FunctionExpression constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
    }
    this.type = 'FunctionExpression';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class Getter {
  constructor({ name, body }) {
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Getter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Getter constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
    }
    this.type = 'Getter';
    this.name = name;
    this.body = body;
  }
}

export class IdentifierExpression {
  constructor({ name }) {
    if (typeof name !== 'string') {
      throw new TypeError('Field "name" of IdentifierExpression constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
    }
    this.type = 'IdentifierExpression';
    this.name = name;
  }
}

export class IfStatement {
  constructor({ test, consequent, alternate }) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of IfStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
    }
    if (isNotStatement(consequent)) {
      throw new TypeError('Field "consequent" of IfStatement constructor is of incorrect type (expected Statement, got ' + printActualType(consequent) + ')');
    }
    if (typeof alternate === 'undefined' || alternate !== null && (isNotStatement(alternate))) {
      throw new TypeError('Field "alternate" of IfStatement constructor is of incorrect type (expected null or Statement, got ' + printActualType(alternate) + ')');
    }
    this.type = 'IfStatement';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
}

export class Import {
  constructor({ defaultBinding, namedImports, moduleSpecifier }) {
    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "defaultBinding" of Import constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
    }
    if (typeof namedImports === 'undefined' || !Array.isArray(namedImports) || namedImports.some(f => typeof f === 'undefined' || f.type !== 'ImportSpecifier')) {
      throw new TypeError('Field "namedImports" of Import constructor is of incorrect type (expected [ImportSpecifier], got ' + printActualType(namedImports) + ')');
    }
    if (typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of Import constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
    }
    this.type = 'Import';
    this.defaultBinding = defaultBinding;
    this.namedImports = namedImports;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ImportNamespace {
  constructor({ defaultBinding, namespaceBinding, moduleSpecifier }) {
    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {
      throw new TypeError('Field "defaultBinding" of ImportNamespace constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
    }
    if (typeof namespaceBinding === 'undefined' || namespaceBinding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "namespaceBinding" of ImportNamespace constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(namespaceBinding) + ')');
    }
    if (typeof moduleSpecifier !== 'string') {
      throw new TypeError('Field "moduleSpecifier" of ImportNamespace constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
    }
    this.type = 'ImportNamespace';
    this.defaultBinding = defaultBinding;
    this.namespaceBinding = namespaceBinding;
    this.moduleSpecifier = moduleSpecifier;
  }
}

export class ImportSpecifier {
  constructor({ name, binding }) {
    if (typeof name === 'undefined' || name !== null && (typeof name !== 'string')) {
      throw new TypeError('Field "name" of ImportSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(name) + ')');
    }
    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {
      throw new TypeError('Field "binding" of ImportSpecifier constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
    }
    this.type = 'ImportSpecifier';
    this.name = name;
    this.binding = binding;
  }
}

export class LabeledStatement {
  constructor({ label, body }) {
    if (typeof label !== 'string') {
      throw new TypeError('Field "label" of LabeledStatement constructor is of incorrect type (expected string, got ' + printActualType(label) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of LabeledStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'LabeledStatement';
    this.label = label;
    this.body = body;
  }
}

export class LiteralBooleanExpression {
  constructor({ value }) {
    if (typeof value !== 'boolean') {
      throw new TypeError('Field "value" of LiteralBooleanExpression constructor is of incorrect type (expected boolean, got ' + printActualType(value) + ')');
    }
    this.type = 'LiteralBooleanExpression';
    this.value = value;
  }
}

export class LiteralInfinityExpression {
  constructor() {
    this.type = 'LiteralInfinityExpression';
  }
}

export class LiteralNullExpression {
  constructor() {
    this.type = 'LiteralNullExpression';
  }
}

export class LiteralNumericExpression {
  constructor({ value }) {
    if (typeof value !== 'number') {
      throw new TypeError('Field "value" of LiteralNumericExpression constructor is of incorrect type (expected number, got ' + printActualType(value) + ')');
    }
    this.type = 'LiteralNumericExpression';
    this.value = value;
  }
}

export class LiteralRegExpExpression {
  constructor({ pattern, global, ignoreCase, multiLine, sticky, unicode }) {
    if (typeof pattern !== 'string') {
      throw new TypeError('Field "pattern" of LiteralRegExpExpression constructor is of incorrect type (expected string, got ' + printActualType(pattern) + ')');
    }
    if (typeof global !== 'boolean') {
      throw new TypeError('Field "global" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(global) + ')');
    }
    if (typeof ignoreCase !== 'boolean') {
      throw new TypeError('Field "ignoreCase" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(ignoreCase) + ')');
    }
    if (typeof multiLine !== 'boolean') {
      throw new TypeError('Field "multiLine" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(multiLine) + ')');
    }
    if (typeof sticky !== 'boolean') {
      throw new TypeError('Field "sticky" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(sticky) + ')');
    }
    if (typeof unicode !== 'boolean') {
      throw new TypeError('Field "unicode" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(unicode) + ')');
    }
    this.type = 'LiteralRegExpExpression';
    this.pattern = pattern;
    this.global = global;
    this.ignoreCase = ignoreCase;
    this.multiLine = multiLine;
    this.sticky = sticky;
    this.unicode = unicode;
  }
}

export class LiteralStringExpression {
  constructor({ value }) {
    if (typeof value !== 'string') {
      throw new TypeError('Field "value" of LiteralStringExpression constructor is of incorrect type (expected string, got ' + printActualType(value) + ')');
    }
    this.type = 'LiteralStringExpression';
    this.value = value;
  }
}

export class Method {
  constructor({ isGenerator, name, params, body }) {
    if (typeof isGenerator !== 'boolean') {
      throw new TypeError('Field "isGenerator" of Method constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
    }
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Method constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {
      throw new TypeError('Field "params" of Method constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Method constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
    }
    this.type = 'Method';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  }
}

export class Module {
  constructor({ directives, items }) {
    if (typeof directives === 'undefined' || !Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of Module constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
    }
    if (typeof items === 'undefined' || !Array.isArray(items) || items.some(f => typeof f === 'undefined' || ((f.type !== 'Export') && (f.type !== 'ExportAllFrom') && (f.type !== 'ExportDefault') && (f.type !== 'ExportFrom') && (f.type !== 'ExportLocals')) && ((f.type !== 'Import') && (f.type !== 'ImportNamespace')) && (isNotStatement(f)))) {
      throw new TypeError('Field "items" of Module constructor is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got ' + printActualType(items) + ')');
    }
    this.type = 'Module';
    this.directives = directives;
    this.items = items;
  }
}

export class NewExpression {
  constructor({ callee, arguments: _arguments }) {
    if (isNotExpression(callee)) {
      throw new TypeError('Field "callee" of NewExpression constructor is of incorrect type (expected Expression, got ' + printActualType(callee) + ')');
    }
    if (typeof _arguments === 'undefined' || !Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {
      throw new TypeError('Field "arguments" of NewExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
    }
    this.type = 'NewExpression';
    this.callee = callee;
    this.arguments = _arguments;
  }
}

export class NewTargetExpression {
  constructor() {
    this.type = 'NewTargetExpression';
  }
}

export class ObjectAssignmentTarget {
  constructor({ properties }) {
    if (typeof properties === 'undefined' || !Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || (f.type !== 'AssignmentTargetPropertyIdentifier') && (f.type !== 'AssignmentTargetPropertyProperty'))) {
      throw new TypeError('Field "properties" of ObjectAssignmentTarget constructor is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got ' + printActualType(properties) + ')');
    }
    this.type = 'ObjectAssignmentTarget';
    this.properties = properties;
  }
}

export class ObjectBinding {
  constructor({ properties }) {
    if (typeof properties === 'undefined' || !Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || (f.type !== 'BindingPropertyIdentifier') && (f.type !== 'BindingPropertyProperty'))) {
      throw new TypeError('Field "properties" of ObjectBinding constructor is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got ' + printActualType(properties) + ')');
    }
    this.type = 'ObjectBinding';
    this.properties = properties;
  }
}

export class ObjectExpression {
  constructor({ properties }) {
    if (typeof properties === 'undefined' || !Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || ((f.type !== 'DataProperty') && ((f.type !== 'Getter') && (f.type !== 'Method') && (f.type !== 'Setter'))) && (f.type !== 'ShorthandProperty'))) {
      throw new TypeError('Field "properties" of ObjectExpression constructor is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty}], got ' + printActualType(properties) + ')');
    }
    this.type = 'ObjectExpression';
    this.properties = properties;
  }
}

export class ReturnStatement {
  constructor({ expression }) {
    if (typeof expression === 'undefined' || expression !== null && (isNotExpression(expression))) {
      throw new TypeError('Field "expression" of ReturnStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ReturnStatement';
    this.expression = expression;
  }
}

export class Script {
  constructor({ directives, statements }) {
    if (typeof directives === 'undefined' || !Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {
      throw new TypeError('Field "directives" of Script constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
    }
    if (typeof statements === 'undefined' || !Array.isArray(statements) || statements.some(f => isNotStatement(f))) {
      throw new TypeError('Field "statements" of Script constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
    }
    this.type = 'Script';
    this.directives = directives;
    this.statements = statements;
  }
}

export class Setter {
  constructor({ name, param, body }) {
    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {
      throw new TypeError('Field "name" of Setter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
    }
    if (typeof param === 'undefined' || (param.type !== 'BindingWithDefault') && ((param.type !== 'BindingIdentifier') && ((param.type !== 'ArrayBinding') && (param.type !== 'ObjectBinding')))) {
      throw new TypeError('Field "param" of Setter constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(param) + ')');
    }
    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {
      throw new TypeError('Field "body" of Setter constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
    }
    this.type = 'Setter';
    this.name = name;
    this.param = param;
    this.body = body;
  }
}

export class ShorthandProperty {
  constructor({ name }) {
    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {
      throw new TypeError('Field "name" of ShorthandProperty constructor is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
    }
    this.type = 'ShorthandProperty';
    this.name = name;
  }
}

export class SpreadElement {
  constructor({ expression }) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of SpreadElement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'SpreadElement';
    this.expression = expression;
  }
}

export class StaticMemberAssignmentTarget {
  constructor({ object, property }) {
    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of StaticMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
    }
    if (typeof property !== 'string') {
      throw new TypeError('Field "property" of StaticMemberAssignmentTarget constructor is of incorrect type (expected string, got ' + printActualType(property) + ')');
    }
    this.type = 'StaticMemberAssignmentTarget';
    this.object = object;
    this.property = property;
  }
}

export class StaticMemberExpression {
  constructor({ object, property }) {
    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {
      throw new TypeError('Field "object" of StaticMemberExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
    }
    if (typeof property !== 'string') {
      throw new TypeError('Field "property" of StaticMemberExpression constructor is of incorrect type (expected string, got ' + printActualType(property) + ')');
    }
    this.type = 'StaticMemberExpression';
    this.object = object;
    this.property = property;
  }
}

export class StaticPropertyName {
  constructor({ value }) {
    if (typeof value !== 'string') {
      throw new TypeError('Field "value" of StaticPropertyName constructor is of incorrect type (expected string, got ' + printActualType(value) + ')');
    }
    this.type = 'StaticPropertyName';
    this.value = value;
  }
}

export class Super {
  constructor() {
    this.type = 'Super';
  }
}

export class SwitchCase {
  constructor({ test, consequent }) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of SwitchCase constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
    }
    if (typeof consequent === 'undefined' || !Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {
      throw new TypeError('Field "consequent" of SwitchCase constructor is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
    }
    this.type = 'SwitchCase';
    this.test = test;
    this.consequent = consequent;
  }
}

export class SwitchDefault {
  constructor({ consequent }) {
    if (typeof consequent === 'undefined' || !Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {
      throw new TypeError('Field "consequent" of SwitchDefault constructor is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
    }
    this.type = 'SwitchDefault';
    this.consequent = consequent;
  }
}

export class SwitchStatement {
  constructor({ discriminant, cases }) {
    if (isNotExpression(discriminant)) {
      throw new TypeError('Field "discriminant" of SwitchStatement constructor is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
    }
    if (typeof cases === 'undefined' || !Array.isArray(cases) || cases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "cases" of SwitchStatement constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(cases) + ')');
    }
    this.type = 'SwitchStatement';
    this.discriminant = discriminant;
    this.cases = cases;
  }
}

export class SwitchStatementWithDefault {
  constructor({ discriminant, preDefaultCases, defaultCase, postDefaultCases }) {
    if (isNotExpression(discriminant)) {
      throw new TypeError('Field "discriminant" of SwitchStatementWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
    }
    if (typeof preDefaultCases === 'undefined' || !Array.isArray(preDefaultCases) || preDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "preDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(preDefaultCases) + ')');
    }
    if (typeof defaultCase === 'undefined' || defaultCase.type !== 'SwitchDefault') {
      throw new TypeError('Field "defaultCase" of SwitchStatementWithDefault constructor is of incorrect type (expected SwitchDefault, got ' + printActualType(defaultCase) + ')');
    }
    if (typeof postDefaultCases === 'undefined' || !Array.isArray(postDefaultCases) || postDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {
      throw new TypeError('Field "postDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(postDefaultCases) + ')');
    }
    this.type = 'SwitchStatementWithDefault';
    this.discriminant = discriminant;
    this.preDefaultCases = preDefaultCases;
    this.defaultCase = defaultCase;
    this.postDefaultCases = postDefaultCases;
  }
}

export class TemplateElement {
  constructor({ rawValue }) {
    if (typeof rawValue !== 'string') {
      throw new TypeError('Field "rawValue" of TemplateElement constructor is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
    }
    this.type = 'TemplateElement';
    this.rawValue = rawValue;
  }
}

export class TemplateExpression {
  constructor({ tag, elements }) {
    if (typeof tag === 'undefined' || tag !== null && (isNotExpression(tag))) {
      throw new TypeError('Field "tag" of TemplateExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(tag) + ')');
    }
    if (typeof elements === 'undefined' || !Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'TemplateElement'))) {
      throw new TypeError('Field "elements" of TemplateExpression constructor is of incorrect type (expected [one of {Expression, TemplateElement}], got ' + printActualType(elements) + ')');
    }
    this.type = 'TemplateExpression';
    this.tag = tag;
    this.elements = elements;
  }
}

export class ThisExpression {
  constructor() {
    this.type = 'ThisExpression';
  }
}

export class ThrowStatement {
  constructor({ expression }) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of ThrowStatement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'ThrowStatement';
    this.expression = expression;
  }
}

export class TryCatchStatement {
  constructor({ body, catchClause }) {
    if (typeof body === 'undefined' || body.type !== 'Block') {
      throw new TypeError('Field "body" of TryCatchStatement constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
    }
    if (typeof catchClause === 'undefined' || catchClause.type !== 'CatchClause') {
      throw new TypeError('Field "catchClause" of TryCatchStatement constructor is of incorrect type (expected CatchClause, got ' + printActualType(catchClause) + ')');
    }
    this.type = 'TryCatchStatement';
    this.body = body;
    this.catchClause = catchClause;
  }
}

export class TryFinallyStatement {
  constructor({ body, catchClause, finalizer }) {
    if (typeof body === 'undefined' || body.type !== 'Block') {
      throw new TypeError('Field "body" of TryFinallyStatement constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
    }
    if (typeof catchClause === 'undefined' || catchClause !== null && (catchClause.type !== 'CatchClause')) {
      throw new TypeError('Field "catchClause" of TryFinallyStatement constructor is of incorrect type (expected null or CatchClause, got ' + printActualType(catchClause) + ')');
    }
    if (typeof finalizer === 'undefined' || finalizer.type !== 'Block') {
      throw new TypeError('Field "finalizer" of TryFinallyStatement constructor is of incorrect type (expected Block, got ' + printActualType(finalizer) + ')');
    }
    this.type = 'TryFinallyStatement';
    this.body = body;
    this.catchClause = catchClause;
    this.finalizer = finalizer;
  }
}

export class UnaryExpression {
  constructor({ operator, operand }) {
    if (typeof operator === 'undefined' || ['+', '-', '!', '~', 'typeof', 'void', 'delete'].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of UnaryExpression constructor is of incorrect type (expected one of {"+", "-", "!", "~", "typeof", "void", "delete"}, got ' + printActualType(operator) + ')');
    }
    if (isNotExpression(operand)) {
      throw new TypeError('Field "operand" of UnaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(operand) + ')');
    }
    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
  }
}

export class UpdateExpression {
  constructor({ isPrefix, operator, operand }) {
    if (typeof isPrefix !== 'boolean') {
      throw new TypeError('Field "isPrefix" of UpdateExpression constructor is of incorrect type (expected boolean, got ' + printActualType(isPrefix) + ')');
    }
    if (typeof operator === 'undefined' || ['++', '--'].indexOf(operator) === -1) {
      throw new TypeError('Field "operator" of UpdateExpression constructor is of incorrect type (expected one of {"++", "--"}, got ' + printActualType(operator) + ')');
    }
    if (typeof operand === 'undefined' || (operand.type !== 'AssignmentTargetIdentifier') && ((operand.type !== 'ComputedMemberAssignmentTarget') && (operand.type !== 'StaticMemberAssignmentTarget'))) {
      throw new TypeError('Field "operand" of UpdateExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(operand) + ')');
    }
    this.type = 'UpdateExpression';
    this.isPrefix = isPrefix;
    this.operator = operator;
    this.operand = operand;
  }
}

export class VariableDeclaration {
  constructor({ kind, declarators }) {
    if (typeof kind === 'undefined' || ['var', 'let', 'const'].indexOf(kind) === -1) {
      throw new TypeError('Field "kind" of VariableDeclaration constructor is of incorrect type (expected one of {"var", "let", "const"}, got ' + printActualType(kind) + ')');
    }
    if (typeof declarators === 'undefined' || !Array.isArray(declarators) || declarators.some(f => typeof f === 'undefined' || f.type !== 'VariableDeclarator')) {
      throw new TypeError('Field "declarators" of VariableDeclaration constructor is of incorrect type (expected [VariableDeclarator], got ' + printActualType(declarators) + ')');
    }
    this.type = 'VariableDeclaration';
    this.kind = kind;
    this.declarators = declarators;
  }
}

export class VariableDeclarationStatement {
  constructor({ declaration }) {
    if (typeof declaration === 'undefined' || declaration.type !== 'VariableDeclaration') {
      throw new TypeError('Field "declaration" of VariableDeclarationStatement constructor is of incorrect type (expected VariableDeclaration, got ' + printActualType(declaration) + ')');
    }
    this.type = 'VariableDeclarationStatement';
    this.declaration = declaration;
  }
}

export class VariableDeclarator {
  constructor({ binding, init }) {
    if (typeof binding === 'undefined' || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {
      throw new TypeError('Field "binding" of VariableDeclarator constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
    }
    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {
      throw new TypeError('Field "init" of VariableDeclarator constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
    }
    this.type = 'VariableDeclarator';
    this.binding = binding;
    this.init = init;
  }
}

export class WhileStatement {
  constructor({ test, body }) {
    if (isNotExpression(test)) {
      throw new TypeError('Field "test" of WhileStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of WhileStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'WhileStatement';
    this.test = test;
    this.body = body;
  }
}

export class WithStatement {
  constructor({ object, body }) {
    if (isNotExpression(object)) {
      throw new TypeError('Field "object" of WithStatement constructor is of incorrect type (expected Expression, got ' + printActualType(object) + ')');
    }
    if (isNotStatement(body)) {
      throw new TypeError('Field "body" of WithStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
    }
    this.type = 'WithStatement';
    this.object = object;
    this.body = body;
  }
}

export class YieldExpression {
  constructor({ expression }) {
    if (typeof expression === 'undefined' || expression !== null && (isNotExpression(expression))) {
      throw new TypeError('Field "expression" of YieldExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'YieldExpression';
    this.expression = expression;
  }
}

export class YieldGeneratorExpression {
  constructor({ expression }) {
    if (isNotExpression(expression)) {
      throw new TypeError('Field "expression" of YieldGeneratorExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
    }
    this.type = 'YieldGeneratorExpression';
    this.expression = expression;
  }
}
